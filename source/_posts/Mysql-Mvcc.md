---
title: 浅入浅出Mysql Innodb Mvcc
date: 2018-12-10 14.21
categories: 
- Mysql
tags:
- Mysql
- Mvcc
---

## MVCC 
>* MVCC 翻译过来就是指 ``多版本控制``
### 多版本控制
>* 指的是一种提高并发的技术
最高的数据库系统, 只有读与读之间可以并发,写与读,读与写,写与写都要阻塞.
引入多版本之后,只有写与写之间会相互阻塞, 其他三种操作都可以并发,
这样大大提升了``Innodb``并发度,在内部实现中，与Postgres在数据行上实现多版本不同，InnoDB是在undolog中实现的，通过``undolog``可以找回数据的历史版本。找回的数据历史版本可以提供给用户读(按照隔离级别的定义，有些读请求只能看到比较老的数据版本)，也可以在回滚的时候覆盖数据页上的数据。在InnoDB内部中，会记录一个全局的活跃读写事务数组，其主要用来判断事务的可见性。
## 并发与并行 
关于并发与并行 只有才多核处理器才能体现
Erlang之父用一张图解释了并发与并行
![图 1](mvcc/concurrent.jpg)
>* 并发是两个队列交替使用一台咖啡机，并行是两个队列``同时``使用两台咖啡机，
如果串行，一个队列使用一台咖啡机，那么哪怕前面那个人便秘了去厕所呆半天，后面的人也只能死等着他回来才能去接咖啡，这效率无疑是最低的。
一台咖啡机就等于计算机中的一核心CPU,单核CPU在计算机时间片调度中同一时刻只有一个任务在执行
多核CPU自然能同时调度多个任务执行啦 ,一个进程可以被多个核心CPU调用这种情况 会产生并行

> 并发是不是一个线程，并行是多个线程？
 答：并发和并行都可以是很多个线程，就看这些线程能不能同时被（多个）cpu执行，
如果可以就说明是并行，而并发是多个线程被（一个）cpu 轮流切换着执行。

>* 总结下 并行是同一时间执行多个任务(多个根据CPU核数决定), 并发是多个任务在同时执行
但是在一段时间内只有一个任务被执行,默认计算的系统调度是抢占方,所以进程/线程过多会导致系统
会很卡
>* 这种方式才传统编程语言中一般是写一个线程池管理 
>* 但是在线程概念提出之前还有一个东西叫``协程`` 也叫用户级线程,也就是说操作系统不会调度,需要语言来实现调用
Golang 就是典型的

扯远了之前简单的简述了并发与并行 
###undolog

1. Undo log是InnoDB MVCC事务特性的重要组成部分。当我们对记录做了变更操作时就会产生undo记录，Undo记录默认被记录到系统表空间(ibdata)中，但从5.6开始，也可以使用独立的Undo 表空间。

2. Undo记录中存储的是老版本数据，当一个旧的事务需要读取数据时，为了能读取到老版本的数据，需要顺着undo链找到满足其可见性的记录。当版本链很长时，通常可以认为这是个比较耗时的操作

3. 大多数对数据的变更操作包括INSERT/DELETE/UPDATE，其中INSERT操作在事务提交前只对当前事务可见，因此产生的Undo日志可以在事务提交后直接删除（谁会对刚插入的数据有可见性需求呢！！），而对于UPDATE/DELETE则需要维护多版本信息，在InnoDB里，UPDATE和DELETE操作产生的Undo日志被归成一类，即update_undo。

4. 另外, 在回滚段中的undo logs分为: insert undo log 和 update undo log
>* insert undo log : 事务对insert新记录时产生的undolog, 只在事务回滚时需要, 并且在事务提交后就可以立即丢弃。
>* update undo log : 事务对记录进行delete和update操作时产生的undo log, 不仅在事务回滚时需要, 一致性读也需要，所以不能随便删除，只有当数据库所使用的快照中不涉及该日志记录，对应的回滚日志才会被purge线程删除。

5.  如果需要设置独立表空间，需要在初始化数据库实例的时候，指定独立表空间的数量。
UNDO内部由多个回滚段组成，即 Rollback segment，一共有128个，保存在ibdata系统表空间中，分别从resg slot0 - resg slot127，每一个resg slot，也就是每一个回滚段，内部由1024个undo segment 组成。
回滚段（rollback segment）分配如下：
> slot 0 ，预留给系统表空间；
slot 1- 32，预留给临时表空间，每次数据库重启的时候，都会重建临时表空间；
slot33-127，如果有独立表空间，则预留给UNDO独立表空间；如果没有，则预留给系统表空间；

回滚段中除去32个提供给临时表事务使用，剩下的 128-32=96个回滚段，可执行 96*1024 个并发事务操作，每个事务占用一个 undo segment slot，注意，如果事务中有临时表事务，还会在临时表空间中的 undo segment slot 再占用一个 undo segment slot，即占用2个undo segment slot。如果错误日志中有：Cannot find a free slot for an undo log。则说明并发的事务太多了，需要考虑下是否要分流业务。
回滚段（rollback segment ）采用 轮询调度的方式来分配使用，如果设置了独立表空间，那么就不会使用系统表空间回滚段中undo segment，而是使用独立表空间的，同时，如果回顾段正在 Truncate操作，则不分配。

### <高性能Mysql>中对MVCC的部分介绍
>* MySQL的大多数事务型存储引擎实现的其实都不是简单的行级锁。
基于提升并发性能的考虑, 它们一般都同时实现了多版本并发控制(MVCC)。
不仅是MySQL, 包括Oracle,PostgreSQL等其他数据库系统也都实现了MVCC, 但各自的实现机制不尽相同, 因为MVCC没有一个统一的实现标准。

>* 可以认为MVCC是行级锁的一个变种, 但是它在很多情况下避免了加锁操作, 因此开销更低。虽然实现机制有所不同, 但大都实现了非阻塞的读操作，写操作也只锁定必要的行。

>* MVCC的实现方式有多种, 典型的有乐观(optimistic)并发控制 和 悲观(pessimistic)并发控制。

>* MVCC只在 ``READ COMMITTED``(提交读) 和 ``REPEATABLE READ``(可重读) 两个隔离级别下工作。其他两个隔离级别够和MVCC不兼容, 因为 READ UNCOMMITTED 总是读取最新的数据行, 而不是符合当前事务版本的数据行。而 SERIALIZABLE 则会对所有读取的行都加锁。(详情参见数据的事物隔离级别)

>从书中可以了解到:
MVCC是被Mysql中 事务型存储引擎InnoDB 所支持的;
应对高并发事务, MVCC比单纯的加锁更高效;
* MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作;
* MVCC可以使用 ``乐观(optimistic)锁`` 和 ``悲观(pessimistic)锁``来实现;

* 各数据库中MVCC实现并不统一,但是书中提到 "InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现的"(网上也有很多此类观点), 但其实并不准确, 可以参考 [MySQL官方文档](https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html), 可以看到, InnoDB存储引擎在数据库每行数据的后面添加了三个字段, 不是两个!!

## 相关概念

